import { StrictMode, useEffect, useState } from "react";
import { createRoot } from "react-dom/client";
import { $router, defineRoutes } from "@sylphx/zen-router";
import { subscribe, get } from "@sylphx/zen";
import { Layout } from "@sylphx/leaf-theme-default";
import "@sylphx/leaf-theme-default/style.css";

// @ts-expect-error - Generated by Vite plugin
import { routes } from "virtual:reactpress/routes";
// @ts-expect-error - Generated by Vite plugin
import config from "virtual:leaf/config";

interface LeafRouteConfig {
	path: string;
	component: React.ComponentType;
	toc: any[];
	docFooter: any;
}

// Convert routes to zen-router format and define them
const zenRoutes: LeafRouteConfig[] = routes.map((route: any) => ({
	path: route.path === "/" ? "/" : route.path,
	component: route.component,
	toc: route.toc || [],
	docFooter: route.docFooter,
}));

defineRoutes(zenRoutes);

// Simple route matcher (since zen-router doesn't export matchRoutes)
function findMatchingRoute(pathname: string, routes: LeafRouteConfig[]): LeafRouteConfig | null {
	// Normalize path
	const normalizedPath = pathname === "" ? "/" : pathname;

	// Try exact match first
	const exactMatch = routes.find(r => r.path === normalizedPath);
	if (exactMatch) return exactMatch;

	// Try catch-all route
	const catchAll = routes.find(r => r.path === "*");
	return catchAll || null;
}

// App component that subscribes to router state
function App() {
	const [routerState, setRouterState] = useState(() => get($router));

	useEffect(() => {
		// Subscribe to router changes
		const unsubscribe = subscribe($router, setRouterState);

		// Listen to browser back/forward
		const handlePopState = () => {
			const newState = get($router);
			setRouterState(newState);
		};
		window.addEventListener("popstate", handlePopState);

		return () => {
			unsubscribe();
			window.removeEventListener("popstate", handlePopState);
		};
	}, []);

	// Handle scroll restoration on route change
	useEffect(() => {
		const hash = window.location.hash;

		if (hash) {
			// Wait for React to render, then scroll to hash target
			// Use requestAnimationFrame + setTimeout for better timing
			requestAnimationFrame(() => {
				setTimeout(() => {
					const element = document.querySelector(hash);
					if (element) {
						element.scrollIntoView({ behavior: 'smooth' });
					}
				}, 100);
			});
		} else {
			// No hash - scroll to top
			window.scrollTo(0, 0);
		}
	}, [routerState.path]);

	// Handle same-page hash navigation (e.g., clicking TOC)
	useEffect(() => {
		const handleHashChange = () => {
			const hash = window.location.hash;
			if (hash) {
				// Use requestAnimationFrame for smooth scroll
				requestAnimationFrame(() => {
					const element = document.querySelector(hash);
					if (element) {
						element.scrollIntoView({ behavior: 'smooth' });
					}
				});
			}
		};

		window.addEventListener('hashchange', handleHashChange);
		return () => window.removeEventListener('hashchange', handleHashChange);
	}, []);

	// Match current route
	const route = findMatchingRoute(routerState.path, zenRoutes);

	if (!route) {
		return (
			<Layout config={config} currentRoute={null}>
				<div className="prose prose-slate dark:prose-invert max-w-none">
					<h1>404 - Page Not Found</h1>
					<p>The page you're looking for doesn't exist.</p>
				</div>
			</Layout>
		);
	}

	const Component = route.component;

	return (
		<Layout
			config={config}
			currentRoute={{
				path: routerState.path,
				toc: route.toc,
				docFooter: route.docFooter,
			}}
		>
			<Component />
		</Layout>
	);
}

const rootElement = document.getElementById("root");

if (!rootElement) {
	throw new Error("Root element not found");
}

createRoot(rootElement).render(
	<StrictMode>
		<App />
	</StrictMode>,
);
